<!DOCTYPE html>
<html>
<head>
    <title>GPT-2 Circuit Analysis</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --border: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent: #58a6ff;
            --accent-hover: #79c0ff;
            --success: #3fb950;
            --warning: #d29922;
            --danger: #f85149;
            --gradient: linear-gradient(135deg, #58a6ff 0%, #a371f7 100%);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Header */
        .header {
            text-align: center;
            padding: 40px 0;
            border-bottom: 1px solid var(--border);
            margin-bottom: 32px;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 600;
            background: var(--gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 24px;
            background: var(--bg-secondary);
            padding: 4px;
            border-radius: 12px;
            width: fit-content;
        }

        .tab {
            padding: 12px 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .tab:hover {
            color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .tab.active {
            background: var(--accent);
            color: #fff;
        }

        /* Cards */
        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .card-subtitle {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-top: 4px;
        }

        /* Form Elements */
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        input, select, textarea {
            padding: 10px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            transition: all 0.2s ease;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(88, 166, 255, 0.15);
        }

        input::placeholder {
            color: var(--text-muted);
        }

        /* Buttons */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--accent);
            color: #fff;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }

        /* Grid for head selection */
        .head-grid {
            display: grid;
            grid-template-columns: auto repeat(12, 1fr);
            gap: 3px;
            background: var(--bg-tertiary);
            padding: 16px;
            border-radius: 12px;
            font-size: 11px;
        }

        .head-grid-label {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-weight: 500;
            padding: 4px;
        }

        .head-grid-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-secondary);
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
            font-size: 9px;
            color: var(--text-muted);
            position: relative;
        }

        .head-grid-cell:hover {
            border-color: var(--accent);
            transform: scale(1.1);
            z-index: 10;
        }

        .head-grid-cell.selected {
            border-color: #ff10f0;
            box-shadow: 0 0 8px rgba(255, 16, 240, 0.6);
        }

        .head-grid-cell.selected::after {
            content: '✓';
            position: absolute;
            font-size: 10px;
            color: #ff10f0;
            font-weight: bold;
        }

        .head-grid-cell .tooltip {
            display: none;
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            padding: 8px 12px;
            border-radius: 8px;
            white-space: nowrap;
            font-size: 11px;
            z-index: 100;
            color: var(--text-primary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .head-grid-cell:hover .tooltip {
            display: block;
        }

        /* Results */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .result-card {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 16px;
        }

        .result-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .result-value {
            font-size: 1.5rem;
            font-weight: 600;
            font-family: 'SF Mono', 'Consolas', monospace;
        }

        .result-value.positive { color: var(--success); }
        .result-value.negative { color: var(--danger); }
        .result-value.neutral { color: var(--warning); }

        /* Token Lists */
        .tokens-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .token-list {
            background: var(--bg-tertiary);
            border-radius: 8px;
            overflow: hidden;
        }

        .token-list-header {
            padding: 12px 16px;
            background: var(--bg-primary);
            font-weight: 500;
            font-size: 0.875rem;
            border-bottom: 1px solid var(--border);
        }

        .token-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            border-bottom: 1px solid var(--border);
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 13px;
            transition: background 0.15s ease;
        }

        .token-item:last-child {
            border-bottom: none;
        }

        .token-item:hover {
            background: var(--bg-secondary);
        }

        .token-item.clickable {
            cursor: pointer;
        }

        .token-item.selected {
            background: rgba(255, 16, 240, 0.1);
            border-left: 3px solid #ff10f0;
        }

        .token-name {
            color: var(--text-primary);
        }

        .token-prob {
            color: var(--text-muted);
        }

        /* Selection info */
        .selection-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: rgba(255, 16, 240, 0.1);
            border: 1px solid rgba(255, 16, 240, 0.3);
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .selection-count {
            font-weight: 600;
            color: #ff10f0;
        }

        .selection-list {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .clear-btn {
            margin-left: auto;
            padding: 6px 12px;
            font-size: 12px;
        }

        /* Legend */
        .legend {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: 16px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        /* Loading state */
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Section titles */
        .section-title {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .section-title h3 {
            font-size: 1rem;
            font-weight: 600;
        }

        .badge {
            padding: 4px 10px;
            background: var(--accent);
            color: #fff;
            font-size: 11px;
            font-weight: 500;
            border-radius: 12px;
        }

        /* Split layout */
        .split-layout {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 24px;
        }

        @media (max-width: 1024px) {
            .split-layout {
                grid-template-columns: 1fr;
            }
        }

        /* Detail panel */
        .detail-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            position: sticky;
            top: 24px;
        }

        .detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--border);
        }

        .detail-row:last-child {
            border-bottom: none;
        }

        .metric-select {
            padding: 8px 12px;
            font-size: 13px;
            min-width: 200px;
        }

        /* Sweep top tokens */
        .sweep-tokens {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        @media (max-width: 768px) {
            .sweep-tokens {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container" x-data="circuitAnalysis()">
        <header class="header">
            <h1>GPT-2 Circuit Analysis</h1>
            <p>Explore attention head contributions through activation patching and ablation</p>
        </header>

        <div class="tabs">
            <button class="tab" :class="{ 'active': activeTab === 'sweep' }" @click="activeTab = 'sweep'">Ablation Sweep</button>
            <button class="tab" :class="{ 'active': activeTab === 'patchsweep' }" @click="activeTab = 'patchsweep'">Patch Sweep</button>
            <button class="tab" :class="{ 'active': activeTab === 'residual' }" @click="activeTab = 'residual'">Residual Stream</button>
            <button class="tab" :class="{ 'active': activeTab === 'mlp' }" @click="activeTab = 'mlp'">MLP</button>
            <button class="tab" :class="{ 'active': activeTab === 'sae' }" @click="activeTab = 'sae'">SAE Features</button>
        </div>

        <!-- Sweep Tab -->
        <div x-show="activeTab === 'sweep'">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Full Head Sweep</div>
                        <div class="card-subtitle">Ablate all 144 heads and visualize their importance</div>
                    </div>
                    <select x-model="sweepMetric" @change="updateGridColors()" class="metric-select">
                        <option value="delta_probs">Δprob (probability drop)</option>
                        <option value="delta_margins">Δmargin (logit margin)</option>
                        <option value="delta_ranks">Δrank (rank degradation)</option>
                        <option value="delta_entropies">Δentropy (distribution flattening)</option>
                    </select>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>Clean Prompt</label>
                        <input type="text" x-model="sweepCleanPrompt">
                    </div>
                    <div class="form-group">
                        <label>Target Token</label>
                        <input type="text" x-model="sweepTargetToken">
                    </div>
                </div>

                <button class="btn btn-primary" @click="runSweep()" :disabled="sweepLoading">
                    <span x-show="sweepLoading" class="loading"></span>
                    <span x-text="sweepLoading ? 'Running sweep...' : 'Run Full Sweep (144 heads)'"></span>
                </button>
            </div>

            <div x-show="sweepData !== null">
                <div class="card">
                    <div class="section-title">
                        <h3>Top-10 Tokens (Clean)</h3>
                    </div>
                    <div class="sweep-tokens" id="sweepTopClean"></div>
                </div>

                <div x-show="sweepSelectedHeads.size > 0" class="selection-info">
                    <span class="selection-count" x-text="sweepSelectedHeads.size + ' head' + (sweepSelectedHeads.size > 1 ? 's' : '') + ' selected'"></span>
                    <span class="selection-list" x-text="getSelectedHeadsList(sweepSelectedHeads)"></span>
                    <button class="btn btn-secondary clear-btn" @click="clearSweepSelection()">Clear All</button>
                </div>

                <div class="card">
                    <div class="section-title">
                        <h3>Attention Head Importance</h3>
                        <span style="color: var(--text-muted); font-size: 12px;">Click to select heads for multi-ablation</span>
                    </div>
                    <div class="head-grid" id="gridContainer"></div>
                    <div class="legend" id="gridLegend"></div>
                    <div class="btn-group" style="margin-top: 16px;">
                        <button class="btn btn-primary" @click="runMultiAblate()" :disabled="multiAblateLoading">
                            <span x-show="multiAblateLoading" class="loading"></span>
                            <span x-text="multiAblateLoading ? 'Ablating...' : 'Ablate Selected Heads'"></span>
                        </button>
                        <button class="btn btn-secondary" @click="clearSweepSelection()">Clear Selection</button>
                    </div>
                </div>

                <div x-show="multiAblateResults !== null" class="card">
                    <div class="card-header">
                        <div class="card-title">Multi-Ablation Results</div>
                    </div>

                    <template x-if="multiAblateResults">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-bottom: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiAblateResults.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiAblateResults.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Ablated</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiAblateResults.ablated_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiAblateResults.ablated_rank"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Δprob</span><span style="font-family: monospace;" x-text="(multiAblateResults.delta_prob >= 0 ? '+' : '') + multiAblateResults.delta_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Δmargin</span><span style="font-family: monospace;" x-text="(multiAblateResults.delta_margin >= 0 ? '+' : '') + multiAblateResults.delta_margin.toFixed(3)"></span></div>
                            </div>
                        </div>
                    </template>

                    <template x-if="multiAblateResults">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Clean</div>
                                <div id="ma_top_clean"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Ablated</div>
                                <div id="ma_top_ablated"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Patch Sweep Tab -->
        <div x-show="activeTab === 'patchsweep'">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Activation Patching Sweep</div>
                        <div class="card-subtitle">Patch clean activations into corrupt runs to find heads that store/pass variable bindings</div>
                    </div>
                    <select x-model="patchMetric" @change="updatePatchGridColors()" class="metric-select">
                        <option value="recovery">Recovery % (how much target prob is recovered)</option>
                        <option value="prob">Patched Probability (raw P(target))</option>
                    </select>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>Clean Prompt</label>
                        <input type="text" x-model="patchCleanPrompt">
                    </div>
                    <div class="form-group">
                        <label>Corrupt Prompt</label>
                        <input type="text" x-model="patchCorruptPrompt">
                    </div>
                    <div class="form-group">
                        <label>Target Token</label>
                        <input type="text" x-model="patchTargetToken">
                    </div>
                </div>

                <button class="btn btn-primary" @click="runPatchSweep()" :disabled="patchSweepLoading">
                    <span x-show="patchSweepLoading" class="loading"></span>
                    <span x-text="patchSweepLoading ? 'Running patch sweep...' : 'Run Patch Sweep (144 heads)'"></span>
                </button>
            </div>

            <div x-show="patchSweepData !== null">
                <div class="card">
                    <div class="section-title">
                        <h3>Baseline Metrics</h3>
                    </div>
                    <template x-if="patchSweepData">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="patchSweepData.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="patchSweepData.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Corrupt</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="patchSweepData.corrupt_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="patchSweepData.corrupt_rank"></span></div>
                            </div>
                        </div>
                    </template>
                </div>

                <div x-show="patchSelectedHeads.size > 0" class="selection-info">
                    <span class="selection-count" x-text="patchSelectedHeads.size + ' head' + (patchSelectedHeads.size > 1 ? 's' : '') + ' selected'"></span>
                    <span class="selection-list" x-text="getSelectedHeadsList(patchSelectedHeads)"></span>
                    <button class="btn btn-secondary clear-btn" @click="clearPatchSelection()">Clear All</button>
                </div>

                <div class="card">
                    <div class="section-title">
                        <h3>Head Recovery Heatmap</h3>
                        <span style="color: var(--text-muted); font-size: 12px;">Click to select heads for multi-patch</span>
                    </div>
                    <div class="head-grid" id="patchGridContainer"></div>
                    <div class="legend" id="patchGridLegend"></div>
                    <div class="btn-group" style="margin-top: 16px;">
                        <button class="btn btn-primary" @click="runMultiPatch()" :disabled="multiPatchLoading">
                            <span x-show="multiPatchLoading" class="loading"></span>
                            <span x-text="multiPatchLoading ? 'Patching...' : 'Patch Selected Heads'"></span>
                        </button>
                        <button class="btn btn-secondary" @click="clearPatchSelection()">Clear Selection</button>
                    </div>
                </div>

                <div x-show="multiPatchResults !== null" class="card">
                    <div class="card-header">
                        <div class="card-title">Multi-Patch Results</div>
                    </div>

                    <template x-if="multiPatchResults">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiPatchResults.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiPatchResults.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Corrupt</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiPatchResults.corrupt_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiPatchResults.corrupt_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Patched</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiPatchResults.patched_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiPatchResults.patched_rank"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Recovery</span><span style="font-family: monospace;" x-text="multiPatchResults.recovery_pct.toFixed(1) + '%'"></span></div>
                            </div>
                        </div>
                    </template>

                    <template x-if="multiPatchResults">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Clean</div>
                                <div id="mp_top_clean"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Corrupt</div>
                                <div id="mp_top_corrupt"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Patched</div>
                                <div id="mp_top_patched"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- Residual Stream Tab -->
        <div x-show="activeTab === 'residual'">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">Residual Stream Patching</div>
                        <div class="card-subtitle">Patch entire layer residual streams to assess layer-level contributions</div>
                    </div>
                    <select x-model="residualMetric" @change="updateResidualColors()" class="metric-select">
                        <option value="recovery">Recovery % (how much target prob is recovered)</option>
                        <option value="prob">Patched Probability (raw P(target))</option>
                    </select>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>Clean Prompt</label>
                        <input type="text" x-model="residualCleanPrompt">
                    </div>
                    <div class="form-group">
                        <label>Corrupt Prompt</label>
                        <input type="text" x-model="residualCorruptPrompt">
                    </div>
                    <div class="form-group">
                        <label>Target Token</label>
                        <input type="text" x-model="residualTargetToken">
                    </div>
                </div>

                <button class="btn btn-primary" @click="runResidualSweep()" :disabled="residualSweepLoading">
                    <span x-show="residualSweepLoading" class="loading"></span>
                    <span x-text="residualSweepLoading ? 'Running residual sweep...' : 'Run Residual Sweep (12 layers)'"></span>
                </button>
            </div>

            <div x-show="residualSweepData !== null">
                <div class="card">
                    <div class="section-title">
                        <h3>Baseline Metrics</h3>
                    </div>
                    <template x-if="residualSweepData">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="residualSweepData.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="residualSweepData.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Corrupt</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="residualSweepData.corrupt_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="residualSweepData.corrupt_rank"></span></div>
                            </div>
                        </div>
                    </template>
                </div>

                <div x-show="residualSelectedLayers.size > 0" class="selection-info">
                    <span class="selection-count" x-text="residualSelectedLayers.size + ' layer' + (residualSelectedLayers.size > 1 ? 's' : '') + ' selected'"></span>
                    <span class="selection-list" x-text="getSelectedLayersList(residualSelectedLayers)"></span>
                    <button class="btn btn-secondary clear-btn" @click="clearResidualSelection()">Clear All</button>
                </div>

                <div class="card">
                    <div class="section-title">
                        <h3>Layer Recovery</h3>
                        <span style="color: var(--text-muted); font-size: 12px;">Click to select layers for multi-patch</span>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 8px; padding: 16px; background: var(--bg-tertiary); border-radius: 12px;" id="residualLayerGrid"></div>
                    <div class="legend" id="residualLegend"></div>
                    <div class="btn-group" style="margin-top: 16px;">
                        <button class="btn btn-primary" @click="runMultiResidualPatch()" :disabled="multiResidualLoading">
                            <span x-show="multiResidualLoading" class="loading"></span>
                            <span x-text="multiResidualLoading ? 'Patching...' : 'Patch Selected Layers'"></span>
                        </button>
                        <button class="btn btn-secondary" @click="clearResidualSelection()">Clear Selection</button>
                    </div>
                </div>

                <div x-show="multiResidualResults !== null" class="card">
                    <div class="card-header">
                        <div class="card-title">Multi-Layer Patch Results</div>
                    </div>

                    <template x-if="multiResidualResults">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiResidualResults.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiResidualResults.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Corrupt</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiResidualResults.corrupt_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiResidualResults.corrupt_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Patched</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiResidualResults.patched_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiResidualResults.patched_rank"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Recovery</span><span style="font-family: monospace;" x-text="multiResidualResults.recovery_pct.toFixed(1) + '%'"></span></div>
                            </div>
                        </div>
                    </template>

                    <template x-if="multiResidualResults">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Clean</div>
                                <div id="mr_top_clean"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Corrupt</div>
                                <div id="mr_top_corrupt"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Patched</div>
                                <div id="mr_top_patched"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- MLP Tab -->
        <div x-show="activeTab === 'mlp'">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">MLP Layer Patching</div>
                        <div class="card-subtitle">Patch MLP outputs to assess MLP-level contributions</div>
                    </div>
                    <select x-model="mlpMetric" @change="updateMLPColors()" class="metric-select">
                        <option value="recovery">Recovery % (how much target prob is recovered)</option>
                        <option value="prob">Patched Probability (raw P(target))</option>
                    </select>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>Clean Prompt</label>
                        <input type="text" x-model="mlpCleanPrompt">
                    </div>
                    <div class="form-group">
                        <label>Corrupt Prompt</label>
                        <input type="text" x-model="mlpCorruptPrompt">
                    </div>
                    <div class="form-group">
                        <label>Target Token</label>
                        <input type="text" x-model="mlpTargetToken">
                    </div>
                </div>

                <button class="btn btn-primary" @click="runMLPSweep()" :disabled="mlpSweepLoading">
                    <span x-show="mlpSweepLoading" class="loading"></span>
                    <span x-text="mlpSweepLoading ? 'Running MLP sweep...' : 'Run MLP Sweep (12 layers)'"></span>
                </button>
            </div>

            <div x-show="mlpSweepData !== null">
                <div class="card">
                    <div class="section-title">
                        <h3>Baseline Metrics</h3>
                    </div>
                    <template x-if="mlpSweepData">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="mlpSweepData.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="mlpSweepData.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Corrupt</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="mlpSweepData.corrupt_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="mlpSweepData.corrupt_rank"></span></div>
                            </div>
                        </div>
                    </template>
                </div>

                <div x-show="mlpSelectedLayers.size > 0" class="selection-info">
                    <span class="selection-count" x-text="mlpSelectedLayers.size + ' layer' + (mlpSelectedLayers.size > 1 ? 's' : '') + ' selected'"></span>
                    <span class="selection-list" x-text="getSelectedLayersList(mlpSelectedLayers)"></span>
                    <button class="btn btn-secondary clear-btn" @click="clearMLPSelection()">Clear All</button>
                </div>

                <div class="card">
                    <div class="section-title">
                        <h3>MLP Layer Recovery</h3>
                        <span style="color: var(--text-muted); font-size: 12px;">Click to select MLP layers for multi-patch</span>
                    </div>
                    <div style="display: grid; grid-template-columns: repeat(12, 1fr); gap: 8px; padding: 16px; background: var(--bg-tertiary); border-radius: 12px;" id="mlpLayerGrid"></div>
                    <div class="legend" id="mlpLegend"></div>
                    <div class="btn-group" style="margin-top: 16px;">
                        <button class="btn btn-primary" @click="runMultiMLPPatch()" :disabled="multiMLPLoading">
                            <span x-show="multiMLPLoading" class="loading"></span>
                            <span x-text="multiMLPLoading ? 'Patching...' : 'Patch Selected MLP Layers'"></span>
                        </button>
                        <button class="btn btn-secondary" @click="clearMLPSelection()">Clear Selection</button>
                    </div>
                </div>

                <div x-show="multiMLPResults !== null" class="card">
                    <div class="card-header">
                        <div class="card-title">Multi-MLP Patch Results</div>
                    </div>

                    <template x-if="multiMLPResults">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Clean</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiMLPResults.clean_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiMLPResults.clean_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Corrupt</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiMLPResults.corrupt_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiMLPResults.corrupt_rank"></span></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Patched</div>
                                <div class="detail-row"><span style="color: var(--text-muted);">P(target)</span><span style="font-family: monospace;" x-text="multiMLPResults.patched_prob.toFixed(4)"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Rank</span><span style="font-family: monospace;" x-text="'#' + multiMLPResults.patched_rank"></span></div>
                                <div class="detail-row"><span style="color: var(--text-muted);">Recovery</span><span style="font-family: monospace;" x-text="multiMLPResults.recovery_pct.toFixed(1) + '%'"></span></div>
                            </div>
                        </div>
                    </template>

                    <template x-if="multiMLPResults">
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px;">
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Clean</div>
                                <div id="mlp_top_clean"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Corrupt</div>
                                <div id="mlp_top_corrupt"></div>
                            </div>
                            <div>
                                <div style="font-weight: 500; margin-bottom: 8px; color: var(--text-secondary);">Top-5 Patched</div>
                                <div id="mlp_top_patched"></div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>

        <!-- SAE Features Tab -->
        <div x-show="activeTab === 'sae'">
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">SAE Feature Analysis</div>
                        <div class="card-subtitle">Decompose activations into interpretable features using Sparse Autoencoders</div>
                    </div>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group full-width">
                        <label>Input Text</label>
                        <textarea x-model="saeText" rows="3" style="width: 100%; resize: vertical;"></textarea>
                    </div>
                    <div class="form-group">
                        <label>Top K Features per Token</label>
                        <input type="number" x-model.number="saeTopK" min="1" max="50">
                    </div>
                </div>

                <button class="btn btn-primary" @click="runSAEAnalysis()" :disabled="saeLoading">
                    <span x-show="saeLoading" class="loading"></span>
                    <span x-text="saeLoading ? 'Analyzing features...' : 'Analyze Features'"></span>
                </button>
            </div>

            <div x-show="saeResults !== null">
                <div class="card">
                    <div class="section-title">
                        <h3>SAE Info</h3>
                    </div>
                    <template x-if="saeResults">
                        <div>
                            <div class="detail-row"><span style="color: var(--text-muted);">Hook Point</span><span style="font-family: monospace;" x-text="saeResults.hook_point"></span></div>
                            <div class="detail-row"><span style="color: var(--text-muted);">Total Features</span><span style="font-family: monospace;" x-text="saeResults.n_features.toLocaleString()"></span></div>
                        </div>
                    </template>
                </div>

                <div class="card">
                    <div class="section-title">
                        <h3>Top Features (Overall)</h3>
                        <span style="color: var(--text-muted); font-size: 12px;">Click to view on Neuronpedia</span>
                    </div>
                    <div id="saeTopFeatures" style="max-height: 400px; overflow-y: auto;"></div>
                </div>

                <div class="card">
                    <div class="section-title">
                        <h3>Features by Token</h3>
                    </div>
                    <div id="saeTokenFeatures" style="max-height: 500px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function circuitAnalysis() {
            return {
                // Tab state
                activeTab: 'sweep',

                // Sweep state
                sweepData: null,
                sweepSelectedHeads: new Set(),
                selectedSweepClampToken: null,
                sweepMetric: 'delta_probs',
                sweepCleanPrompt: 'Paris is the capital of',
                sweepTargetToken: ' France',
                sweepLoading: false,
                multiAblateLoading: false,
                multiAblateResults: null,

                // Patch sweep state
                patchSweepData: null,
                patchSelectedHeads: new Set(),
                patchMetric: 'recovery',
                patchCleanPrompt: 'John gave Mary the book. Mary gave it to',
                patchCorruptPrompt: 'Bob gave Mary the book. Bob gave it to',
                patchTargetToken: ' John',
                patchSweepLoading: false,
                multiPatchLoading: false,
                multiPatchResults: null,

                // SAE state
                saeText: 'The Eiffel Tower is located in Paris, France. It was built in 1889.',
                saeTopK: 10,
                saeResults: null,
                saeLoading: false,

                // Residual stream state
                residualSweepData: null,
                residualSelectedLayers: new Set(),
                residualMetric: 'recovery',
                residualCleanPrompt: 'John gave Mary the book. Mary gave it to',
                residualCorruptPrompt: 'Bob gave Mary the book. Bob gave it to',
                residualTargetToken: ' John',
                residualSweepLoading: false,
                multiResidualLoading: false,
                multiResidualResults: null,

                // MLP state
                mlpSweepData: null,
                mlpSelectedLayers: new Set(),
                mlpMetric: 'recovery',
                mlpCleanPrompt: 'John gave Mary the book. Mary gave it to',
                mlpCorruptPrompt: 'Bob gave Mary the book. Bob gave it to',
                mlpTargetToken: ' John',
                mlpSweepLoading: false,
                multiMLPLoading: false,
                multiMLPResults: null,

                // Helper methods
                getSelectedHeadsList(headsSet) {
                    return Array.from(headsSet).map(k => {
                        const [l, h] = k.split('-');
                        return `L${l}H${h}`;
                    }).join(', ');
                },

                getSelectedLayersList(layersSet) {
                    return Array.from(layersSet).sort((a, b) => a - b).map(l => `L${l}`).join(', ');
                },

                // Sweep methods
                async runSweep() {
                    this.sweepLoading = true;

                    const data = {
                        clean_prompt: this.sweepCleanPrompt,
                        target_token: this.sweepTargetToken,
                        clamp_token: this.selectedSweepClampToken
                    };

                    try {
                        const resp = await fetch('/sweep', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.sweepData = await resp.json();

                        this.renderSweepTokens();
                        this.renderSweepGrid();
                        this.updateGridColors();
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.sweepLoading = false;
                },

                renderSweepTokens() {
                    if (!this.sweepData || !this.sweepData.top_clean) return;

                    const container = document.getElementById('sweepTopClean');
                    if (!container) return;

                    const html = this.sweepData.top_clean.map((t, i) => {
                        const selectedClass = (this.selectedSweepClampToken === t.token) ? 'selected' : '';
                        return `<div class="token-item clickable ${selectedClass}" onclick="window.alpineInstance.selectSweepClampToken('${t.token.replace(/'/g, "\\'")}')">
                            <span class="token-name">${i+1}. "${t.token}"</span>
                            <span class="token-prob">${t.prob.toFixed(4)}</span>
                        </div>`;
                    }).join('');
                    container.innerHTML = html;
                },

                async selectSweepClampToken(token) {
                    if (this.selectedSweepClampToken === token) {
                        this.selectedSweepClampToken = null;
                    } else {
                        this.selectedSweepClampToken = token;
                    }
                    await this.runSweep();
                },

                renderSweepGrid() {
                    const container = document.getElementById('gridContainer');
                    container.innerHTML = '';

                    // Add header row
                    const emptyCorner = document.createElement('div');
                    emptyCorner.className = 'head-grid-label';
                    container.appendChild(emptyCorner);

                    for (let h = 0; h < 12; h++) {
                        const label = document.createElement('div');
                        label.className = 'head-grid-label';
                        label.textContent = `H${h}`;
                        container.appendChild(label);
                    }

                    // Add rows
                    for (let layer = 0; layer < 12; layer++) {
                        const rowLabel = document.createElement('div');
                        rowLabel.className = 'head-grid-label';
                        rowLabel.textContent = `L${layer}`;
                        container.appendChild(rowLabel);

                        for (let head = 0; head < 12; head++) {
                            const cell = document.createElement('div');
                            cell.className = 'head-grid-cell';
                            cell.dataset.layer = layer;
                            cell.dataset.head = head;

                            const tooltip = document.createElement('div');
                            tooltip.className = 'tooltip';
                            const dProb = this.sweepData.delta_probs[layer][head];
                            const dRank = this.sweepData.delta_ranks[layer][head];
                            const dEntropy = this.sweepData.delta_entropies[layer][head];
                            const dMargin = this.sweepData.delta_margins[layer][head];

                            tooltip.innerHTML = `<strong>L${layer}H${head}</strong><br>Δprob: ${dProb >= 0 ? '+' : ''}${dProb.toFixed(4)}<br>Δrank: ${dRank >= 0 ? '+' : ''}${Math.round(dRank)}<br>Δmargin: ${dMargin >= 0 ? '+' : ''}${dMargin.toFixed(3)}<br><em>Click to select</em>`;

                            cell.appendChild(tooltip);
                            cell.onclick = () => this.toggleSweepHead(layer, head, cell);

                            // Check if already selected
                            if (this.sweepSelectedHeads.has(`${layer}-${head}`)) {
                                cell.classList.add('selected');
                            }

                            container.appendChild(cell);
                        }
                    }
                },

                updateGridColors() {
                    if (!this.sweepData) return;

                    const metricData = this.sweepData[this.sweepMetric];
                    const allValues = metricData.flat();
                    const minVal = Math.min(...allValues);
                    const maxVal = Math.max(...allValues);

                    document.getElementById('gridLegend').innerHTML = `
                        <div class="legend-item"><div class="legend-color" style="background: hsl(220, 70%, 45%);"></div> Low impact</div>
                        <div class="legend-item"><div class="legend-color" style="background: hsl(0, 70%, 55%);"></div> High impact</div>
                        <span style="margin-left: auto; color: var(--text-muted);">Range: ${minVal.toFixed(3)} to ${maxVal.toFixed(3)}</span>
                    `;

                    const cells = document.querySelectorAll('#gridContainer .head-grid-cell');
                    cells.forEach(cell => {
                        const layer = parseInt(cell.dataset.layer);
                        const head = parseInt(cell.dataset.head);
                        const value = metricData[layer][head];

                        const normalized = maxVal > minVal ? (value - minVal) / (maxVal - minVal) : 0.5;
                        const hue = 220 - (normalized * 220);
                        const saturation = 60 + (normalized * 20);
                        const lightness = 35 + (normalized * 25);

                        cell.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    });
                },

                toggleSweepHead(layer, head, cell) {
                    const key = `${layer}-${head}`;

                    if (this.sweepSelectedHeads.has(key)) {
                        this.sweepSelectedHeads.delete(key);
                        cell.classList.remove('selected');
                    } else {
                        this.sweepSelectedHeads.add(key);
                        cell.classList.add('selected');
                    }
                },

                clearSweepSelection() {
                    this.sweepSelectedHeads.clear();
                    document.querySelectorAll('#gridContainer .head-grid-cell').forEach(c => c.classList.remove('selected'));
                    this.multiAblateResults = null;
                },

                async runMultiAblate() {
                    if (this.sweepSelectedHeads.size === 0) {
                        alert('Please select at least one head to ablate');
                        return;
                    }

                    this.multiAblateLoading = true;

                    const heads = Array.from(this.sweepSelectedHeads).map(k => {
                        const [layer, head] = k.split('-').map(Number);
                        return { layer, head };
                    });

                    const data = {
                        clean_prompt: this.sweepCleanPrompt,
                        target_token: this.sweepTargetToken,
                        heads: heads
                    };

                    try {
                        const resp = await fetch('/multi-ablate', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.multiAblateResults = await resp.json();

                        // Wait for Alpine to update the DOM before accessing elements
                        await this.$nextTick();

                        this.renderMultiAblateTokens(this.multiAblateResults.top_clean, 'ma_top_clean');
                        this.renderMultiAblateTokens(this.multiAblateResults.top_ablated, 'ma_top_ablated');
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.multiAblateLoading = false;
                },

                renderMultiAblateTokens(tokens, elementId) {
                    const element = document.getElementById(elementId);
                    if (element) {
                        const html = tokens.slice(0, 5).map((t, i) => `
                            <div class="token-item">
                                <span class="token-name">${i+1}. "${t.token}"</span>
                                <span class="token-prob">${t.prob.toFixed(4)}</span>
                            </div>
                        `).join('');
                        element.innerHTML = html;
                    }
                },

                // Patch Sweep methods
                async runPatchSweep() {
                    this.patchSweepLoading = true;

                    const data = {
                        clean_prompt: this.patchCleanPrompt,
                        corrupt_prompt: this.patchCorruptPrompt,
                        target_token: this.patchTargetToken
                    };

                    try {
                        const resp = await fetch('/patch-sweep', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.patchSweepData = await resp.json();

                        this.renderPatchGrid();
                        this.updatePatchGridColors();
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.patchSweepLoading = false;
                },

                renderPatchGrid() {
                    const container = document.getElementById('patchGridContainer');
                    container.innerHTML = '';

                    // Add header row
                    const emptyCorner = document.createElement('div');
                    emptyCorner.className = 'head-grid-label';
                    container.appendChild(emptyCorner);

                    for (let h = 0; h < 12; h++) {
                        const label = document.createElement('div');
                        label.className = 'head-grid-label';
                        label.textContent = `H${h}`;
                        container.appendChild(label);
                    }

                    // Add rows
                    for (let layer = 0; layer < 12; layer++) {
                        const rowLabel = document.createElement('div');
                        rowLabel.className = 'head-grid-label';
                        rowLabel.textContent = `L${layer}`;
                        container.appendChild(rowLabel);

                        for (let head = 0; head < 12; head++) {
                            const cell = document.createElement('div');
                            cell.className = 'head-grid-cell';
                            cell.dataset.layer = layer;
                            cell.dataset.head = head;

                            const tooltip = document.createElement('div');
                            tooltip.className = 'tooltip';
                            const recovery = this.patchSweepData.recovery_matrix[layer][head];
                            const prob = this.patchSweepData.prob_matrix[layer][head];

                            tooltip.innerHTML = `<strong>L${layer}H${head}</strong><br>Recovery: ${recovery.toFixed(1)}%<br>P(target): ${prob.toFixed(4)}`;

                            cell.appendChild(tooltip);
                            cell.onclick = () => this.togglePatchHead(layer, head, cell);

                            // Check if already selected
                            if (this.patchSelectedHeads.has(`${layer}-${head}`)) {
                                cell.classList.add('selected');
                            }

                            container.appendChild(cell);
                        }
                    }
                },

                togglePatchHead(layer, head, cell) {
                    const key = `${layer}-${head}`;

                    if (this.patchSelectedHeads.has(key)) {
                        this.patchSelectedHeads.delete(key);
                        cell.classList.remove('selected');
                    } else {
                        this.patchSelectedHeads.add(key);
                        cell.classList.add('selected');
                    }
                },

                clearPatchSelection() {
                    this.patchSelectedHeads.clear();
                    document.querySelectorAll('#patchGridContainer .head-grid-cell').forEach(c => c.classList.remove('selected'));
                    this.multiPatchResults = null;
                },

                updatePatchGridColors() {
                    if (!this.patchSweepData) return;

                    const metricData = this.patchMetric === 'recovery' ? this.patchSweepData.recovery_matrix : this.patchSweepData.prob_matrix;
                    const allValues = metricData.flat();
                    const minVal = Math.min(...allValues);
                    const maxVal = Math.max(...allValues);

                    document.getElementById('patchGridLegend').innerHTML = `
                        <div class="legend-item"><div class="legend-color" style="background: hsl(220, 70%, 45%);"></div> Low ${this.patchMetric === 'recovery' ? 'recovery' : 'prob'}</div>
                        <div class="legend-item"><div class="legend-color" style="background: hsl(0, 70%, 55%);"></div> High ${this.patchMetric === 'recovery' ? 'recovery' : 'prob'}</div>
                        <span style="margin-left: auto; color: var(--text-muted);">Range: ${minVal.toFixed(3)} to ${maxVal.toFixed(3)}</span>
                    `;

                    const cells = document.querySelectorAll('#patchGridContainer .head-grid-cell');
                    cells.forEach(cell => {
                        const layer = parseInt(cell.dataset.layer);
                        const head = parseInt(cell.dataset.head);
                        const value = metricData[layer][head];

                        const normalized = maxVal > minVal ? (value - minVal) / (maxVal - minVal) : 0.5;
                        const hue = 220 - (normalized * 220);
                        const saturation = 60 + (normalized * 20);
                        const lightness = 35 + (normalized * 25);

                        cell.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    });
                },

                async runMultiPatch() {
                    if (this.patchSelectedHeads.size === 0) {
                        alert('Please select at least one head to patch');
                        return;
                    }

                    this.multiPatchLoading = true;

                    const heads = Array.from(this.patchSelectedHeads).map(k => {
                        const [layer, head] = k.split('-').map(Number);
                        return { layer, head };
                    });

                    const data = {
                        clean_prompt: this.patchCleanPrompt,
                        corrupt_prompt: this.patchCorruptPrompt,
                        target_token: this.patchTargetToken,
                        heads: heads
                    };

                    try {
                        const resp = await fetch('/multi-patch', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.multiPatchResults = await resp.json();

                        // Wait for Alpine to update the DOM before accessing elements
                        await this.$nextTick();

                        const renderTokens = (tokens, elementId) => {
                            const element = document.getElementById(elementId);
                            if (element) {
                                element.innerHTML = tokens.slice(0, 5).map((t, i) =>
                                    `<div class="detail-row" style="font-size: 12px;"><span>"${t.token}"</span><span>${t.prob.toFixed(4)}</span></div>`
                                ).join('');
                            }
                        };

                        renderTokens(this.multiPatchResults.top_clean, 'mp_top_clean');
                        renderTokens(this.multiPatchResults.top_corrupt, 'mp_top_corrupt');
                        renderTokens(this.multiPatchResults.top_patched, 'mp_top_patched');
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.multiPatchLoading = false;
                },

                // SAE methods
                async runSAEAnalysis() {
                    this.saeLoading = true;

                    const data = {
                        text: this.saeText,
                        top_k: this.saeTopK
                    };

                    try {
                        const resp = await fetch('/sae-features', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.saeResults = await resp.json();

                        // Wait for Alpine to update the DOM before accessing elements
                        await this.$nextTick();

                        this.renderSAETopFeatures(this.saeResults.top_features_overall);
                        this.renderSAETokenFeatures(this.saeResults.tokens);
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.saeLoading = false;
                },

                renderSAETopFeatures(features) {
                    const container = document.getElementById('saeTopFeatures');
                    if (!container) return;

                    const html = features.map((f, i) => `
                        <div class="detail-row" style="cursor: pointer;" onclick="window.open('${f.neuronpedia_url}', '_blank')">
                            <span>
                                <span style="color: var(--accent); font-weight: 500;">#${f.feature_index}</span>
                                <span style="color: var(--text-muted); margin-left: 8px;">→ Neuronpedia</span>
                            </span>
                            <span style="font-family: monospace; color: var(--success);">${f.activation.toFixed(4)}</span>
                        </div>
                    `).join('');

                    container.innerHTML = html || '<p style="color: var(--text-muted);">No features activated</p>';
                },

                renderSAETokenFeatures(tokens) {
                    const container = document.getElementById('saeTokenFeatures');
                    if (!container) return;

                    const html = tokens.map((t, i) => {
                        const escapedToken = t.token.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        const featuresList = t.top_features.length > 0
                            ? t.top_features.slice(0, 5).map(f =>
                                `<span class="feature-badge" onclick="window.open('${f.neuronpedia_url}', '_blank')" style="
                                    display: inline-block;
                                    background: var(--bg-tertiary);
                                    border: 1px solid var(--border);
                                    padding: 2px 8px;
                                    margin: 2px;
                                    border-radius: 4px;
                                    font-size: 11px;
                                    cursor: pointer;
                                " title="Activation: ${f.activation.toFixed(4)}">
                                    #${f.feature_index} <span style="color: var(--success);">(${f.activation.toFixed(2)})</span>
                                </span>`
                            ).join('')
                            : '<span style="color: var(--text-muted); font-size: 12px;">No features</span>';

                        return `
                            <div style="margin-bottom: 12px; padding: 8px; background: var(--bg-secondary); border-radius: 6px;">
                                <div style="margin-bottom: 6px;">
                                    <span style="color: var(--text-muted); font-size: 11px;">[${t.position}]</span>
                                    <span style="font-family: monospace; background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px;">${escapedToken}</span>
                                </div>
                                <div>${featuresList}</div>
                            </div>
                        `;
                    }).join('');

                    container.innerHTML = html;
                },

                // Residual Stream methods
                async runResidualSweep() {
                    this.residualSweepLoading = true;

                    const data = {
                        clean_prompt: this.residualCleanPrompt,
                        corrupt_prompt: this.residualCorruptPrompt,
                        target_token: this.residualTargetToken
                    };

                    try {
                        const resp = await fetch('/residual-sweep', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.residualSweepData = await resp.json();

                        this.renderResidualLayerGrid();
                        this.updateResidualColors();
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.residualSweepLoading = false;
                },

                renderResidualLayerGrid() {
                    const container = document.getElementById('residualLayerGrid');
                    if (!container) return;
                    container.innerHTML = '';

                    // Create 12 layer cells
                    for (let layer = 0; layer < 12; layer++) {
                        const cell = document.createElement('div');
                        cell.style.cssText = `
                            aspect-ratio: 1;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            background: var(--bg-secondary);
                            border: 2px solid transparent;
                            border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.15s ease;
                            font-size: 12px;
                            font-weight: 600;
                            position: relative;
                            padding: 8px;
                        `;

                        const label = document.createElement('div');
                        label.textContent = `L${layer}`;
                        label.style.color = 'var(--text-primary)';
                        label.style.marginBottom = '4px';

                        const value = document.createElement('div');
                        const recovery = this.residualSweepData.recovery_by_layer[layer];
                        value.textContent = recovery.toFixed(1) + '%';
                        value.style.fontSize = '10px';
                        value.style.color = 'var(--text-muted)';

                        cell.appendChild(label);
                        cell.appendChild(value);

                        // Add hover effect
                        cell.onmouseenter = () => {
                            if (!this.residualSelectedLayers.has(layer)) {
                                cell.style.borderColor = 'var(--accent)';
                                cell.style.transform = 'scale(1.05)';
                            }
                        };
                        cell.onmouseleave = () => {
                            if (!this.residualSelectedLayers.has(layer)) {
                                cell.style.borderColor = 'transparent';
                                cell.style.transform = 'scale(1)';
                            }
                        };

                        // Add click handler
                        cell.onclick = () => this.toggleResidualLayer(layer, cell);

                        // Check if already selected
                        if (this.residualSelectedLayers.has(layer)) {
                            cell.style.borderColor = '#ff10f0';
                            cell.style.boxShadow = '0 0 8px rgba(255, 16, 240, 0.6)';
                        }

                        container.appendChild(cell);
                    }
                },

                updateResidualColors() {
                    if (!this.residualSweepData) return;

                    const metricData = this.residualMetric === 'recovery'
                        ? this.residualSweepData.recovery_by_layer
                        : this.residualSweepData.prob_by_layer;

                    const minVal = Math.min(...metricData);
                    const maxVal = Math.max(...metricData);

                    const legendContainer = document.getElementById('residualLegend');
                    if (legendContainer) {
                        legendContainer.innerHTML = `
                            <div class="legend-item"><div class="legend-color" style="background: hsl(220, 70%, 45%);"></div> Low ${this.residualMetric === 'recovery' ? 'recovery' : 'prob'}</div>
                            <div class="legend-item"><div class="legend-color" style="background: hsl(0, 70%, 55%);"></div> High ${this.residualMetric === 'recovery' ? 'recovery' : 'prob'}</div>
                            <span style="margin-left: auto; color: var(--text-muted);">Range: ${minVal.toFixed(3)} to ${maxVal.toFixed(3)}</span>
                        `;
                    }

                    const container = document.getElementById('residualLayerGrid');
                    if (!container) return;

                    const cells = container.children;
                    for (let layer = 0; layer < 12; layer++) {
                        const cell = cells[layer];
                        if (!cell) continue;

                        const value = metricData[layer];
                        const normalized = maxVal > minVal ? (value - minVal) / (maxVal - minVal) : 0.5;
                        const hue = 220 - (normalized * 220);
                        const saturation = 60 + (normalized * 20);
                        const lightness = 35 + (normalized * 25);

                        cell.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    }
                },

                toggleResidualLayer(layer, cell) {
                    if (this.residualSelectedLayers.has(layer)) {
                        this.residualSelectedLayers.delete(layer);
                        cell.style.borderColor = 'transparent';
                        cell.style.boxShadow = 'none';
                    } else {
                        this.residualSelectedLayers.add(layer);
                        cell.style.borderColor = '#ff10f0';
                        cell.style.boxShadow = '0 0 8px rgba(255, 16, 240, 0.6)';
                    }
                },

                clearResidualSelection() {
                    this.residualSelectedLayers.clear();
                    const container = document.getElementById('residualLayerGrid');
                    if (container) {
                        Array.from(container.children).forEach(cell => {
                            cell.style.borderColor = 'transparent';
                            cell.style.boxShadow = 'none';
                        });
                    }
                    this.multiResidualResults = null;
                },

                async runMultiResidualPatch() {
                    if (this.residualSelectedLayers.size === 0) {
                        alert('Please select at least one layer to patch');
                        return;
                    }

                    this.multiResidualLoading = true;

                    const layers = Array.from(this.residualSelectedLayers).map(layer => ({ layer }));

                    const data = {
                        clean_prompt: this.residualCleanPrompt,
                        corrupt_prompt: this.residualCorruptPrompt,
                        target_token: this.residualTargetToken,
                        layers: layers
                    };

                    try {
                        const resp = await fetch('/multi-residual-patch', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.multiResidualResults = await resp.json();

                        // Wait for Alpine to update the DOM before accessing elements
                        await this.$nextTick();

                        const renderTokens = (tokens, elementId) => {
                            const element = document.getElementById(elementId);
                            if (element) {
                                element.innerHTML = tokens.slice(0, 5).map((t, i) =>
                                    `<div class="detail-row" style="font-size: 12px;"><span>"${t.token}"</span><span>${t.prob.toFixed(4)}</span></div>`
                                ).join('');
                            }
                        };

                        renderTokens(this.multiResidualResults.top_clean, 'mr_top_clean');
                        renderTokens(this.multiResidualResults.top_corrupt, 'mr_top_corrupt');
                        renderTokens(this.multiResidualResults.top_patched, 'mr_top_patched');
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.multiResidualLoading = false;
                },

                // MLP methods
                async runMLPSweep() {
                    this.mlpSweepLoading = true;

                    const data = {
                        clean_prompt: this.mlpCleanPrompt,
                        corrupt_prompt: this.mlpCorruptPrompt,
                        target_token: this.mlpTargetToken
                    };

                    try {
                        const resp = await fetch('/mlp-sweep', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.mlpSweepData = await resp.json();

                        this.renderMLPLayerGrid();
                        this.updateMLPColors();
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.mlpSweepLoading = false;
                },

                renderMLPLayerGrid() {
                    const container = document.getElementById('mlpLayerGrid');
                    if (!container) return;
                    container.innerHTML = '';

                    // Create 12 MLP layer cells
                    for (let layer = 0; layer < 12; layer++) {
                        const cell = document.createElement('div');
                        cell.style.cssText = `
                            aspect-ratio: 1;
                            display: flex;
                            flex-direction: column;
                            align-items: center;
                            justify-content: center;
                            background: var(--bg-secondary);
                            border: 2px solid transparent;
                            border-radius: 8px;
                            cursor: pointer;
                            transition: all 0.15s ease;
                            font-size: 12px;
                            font-weight: 600;
                            position: relative;
                            padding: 8px;
                        `;

                        const label = document.createElement('div');
                        label.textContent = `MLP${layer}`;
                        label.style.color = 'var(--text-primary)';
                        label.style.marginBottom = '4px';
                        label.style.fontSize = '11px';

                        const value = document.createElement('div');
                        const recovery = this.mlpSweepData.recovery_by_layer[layer];
                        value.textContent = recovery.toFixed(1) + '%';
                        value.style.fontSize = '10px';
                        value.style.color = 'var(--text-muted)';

                        cell.appendChild(label);
                        cell.appendChild(value);

                        // Add hover effect
                        cell.onmouseenter = () => {
                            if (!this.mlpSelectedLayers.has(layer)) {
                                cell.style.borderColor = 'var(--accent)';
                                cell.style.transform = 'scale(1.05)';
                            }
                        };
                        cell.onmouseleave = () => {
                            if (!this.mlpSelectedLayers.has(layer)) {
                                cell.style.borderColor = 'transparent';
                                cell.style.transform = 'scale(1)';
                            }
                        };

                        // Add click handler
                        cell.onclick = () => this.toggleMLPLayer(layer, cell);

                        // Check if already selected
                        if (this.mlpSelectedLayers.has(layer)) {
                            cell.style.borderColor = '#ff10f0';
                            cell.style.boxShadow = '0 0 8px rgba(255, 16, 240, 0.6)';
                        }

                        container.appendChild(cell);
                    }
                },

                updateMLPColors() {
                    if (!this.mlpSweepData) return;

                    const metricData = this.mlpMetric === 'recovery'
                        ? this.mlpSweepData.recovery_by_layer
                        : this.mlpSweepData.prob_by_layer;

                    const minVal = Math.min(...metricData);
                    const maxVal = Math.max(...metricData);

                    const legendContainer = document.getElementById('mlpLegend');
                    if (legendContainer) {
                        legendContainer.innerHTML = `
                            <div class="legend-item"><div class="legend-color" style="background: hsl(220, 70%, 45%);"></div> Low ${this.mlpMetric === 'recovery' ? 'recovery' : 'prob'}</div>
                            <div class="legend-item"><div class="legend-color" style="background: hsl(0, 70%, 55%);"></div> High ${this.mlpMetric === 'recovery' ? 'recovery' : 'prob'}</div>
                            <span style="margin-left: auto; color: var(--text-muted);">Range: ${minVal.toFixed(3)} to ${maxVal.toFixed(3)}</span>
                        `;
                    }

                    const container = document.getElementById('mlpLayerGrid');
                    if (!container) return;

                    const cells = container.children;
                    for (let layer = 0; layer < 12; layer++) {
                        const cell = cells[layer];
                        if (!cell) continue;

                        const value = metricData[layer];
                        const normalized = maxVal > minVal ? (value - minVal) / (maxVal - minVal) : 0.5;
                        const hue = 220 - (normalized * 220);
                        const saturation = 60 + (normalized * 20);
                        const lightness = 35 + (normalized * 25);

                        cell.style.backgroundColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                    }
                },

                toggleMLPLayer(layer, cell) {
                    if (this.mlpSelectedLayers.has(layer)) {
                        this.mlpSelectedLayers.delete(layer);
                        cell.style.borderColor = 'transparent';
                        cell.style.boxShadow = 'none';
                    } else {
                        this.mlpSelectedLayers.add(layer);
                        cell.style.borderColor = '#ff10f0';
                        cell.style.boxShadow = '0 0 8px rgba(255, 16, 240, 0.6)';
                    }
                },

                clearMLPSelection() {
                    this.mlpSelectedLayers.clear();
                    const container = document.getElementById('mlpLayerGrid');
                    if (container) {
                        Array.from(container.children).forEach(cell => {
                            cell.style.borderColor = 'transparent';
                            cell.style.boxShadow = 'none';
                        });
                    }
                    this.multiMLPResults = null;
                },

                async runMultiMLPPatch() {
                    if (this.mlpSelectedLayers.size === 0) {
                        alert('Please select at least one MLP layer to patch');
                        return;
                    }

                    this.multiMLPLoading = true;

                    const layers = Array.from(this.mlpSelectedLayers).map(layer => ({ layer }));

                    const data = {
                        clean_prompt: this.mlpCleanPrompt,
                        corrupt_prompt: this.mlpCorruptPrompt,
                        target_token: this.mlpTargetToken,
                        layers: layers
                    };

                    try {
                        const resp = await fetch('/multi-mlp-patch', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(data)
                        });
                        this.multiMLPResults = await resp.json();

                        // Wait for Alpine to update the DOM before accessing elements
                        await this.$nextTick();

                        const renderTokens = (tokens, elementId) => {
                            const element = document.getElementById(elementId);
                            if (element) {
                                element.innerHTML = tokens.slice(0, 5).map((t, i) =>
                                    `<div class="detail-row" style="font-size: 12px;"><span>"${t.token}"</span><span>${t.prob.toFixed(4)}</span></div>`
                                ).join('');
                            }
                        };

                        renderTokens(this.multiMLPResults.top_clean, 'mlp_top_clean');
                        renderTokens(this.multiMLPResults.top_corrupt, 'mlp_top_corrupt');
                        renderTokens(this.multiMLPResults.top_patched, 'mlp_top_patched');
                    } catch (e) {
                        alert('Error: ' + e.message);
                    }

                    this.multiMLPLoading = false;
                },

                init() {
                    // Store Alpine instance globally for onclick handlers
                    window.alpineInstance = this;
                }
            }
        }
    </script>
</body>
</html>
